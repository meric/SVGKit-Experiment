# require jinja2
import re, csv, textwrap

from jinja2 import Environment, PackageLoader
env = Environment(loader=PackageLoader('svg', 'templates'))

PREFIX = "SK"

def main():
  commands = {"literal":run_literal, "ltype":run_ltype, "type": run_type,
              "attribute":run_attribute}
  state = dict()
  file = open("svg.ssv", "r, b")
  for row in csv.reader(file, delimiter=" "):
    if len(row) and row[0] in commands:
      commands[row[0]](state, row[1:])
  file.close()
  save("SVGKit+DOM.h", svgkit_dom(state, "SVGKit+DOM.j.h"))
  save("SVGKit+DOM.m", svgkit_dom(state, "SVGKit+DOM.j.m"))
  save("SVGKit+Attribute.h", svgkit_dom(state, "SVGKit+Attribute.j.h"))

def svgkit_dom(state, f):
  template = env.get_template(f)
  literals = [state["literals"][k] for k in state["literals"]]
  literals.sort(key=lambda l: l.cstr())
  ltypes = [state["ltypes"][k] for k in state["ltypes"]]
  ctypes = [state["ctypes"][k] for k in state["ctypes"]]
  scanners = [{"name":k, "scan":state["scanners"][k]} for k in state["scanners"]]
  return template.render(literals = literals, 
                         ltypes = ltypes,
                         ctypes = ctypes,
                         scanners = scanners)

def translate(svgName):
  cap = lambda s:s[0].upper()+s[1:]
  return "".join(map(cap, svgName.split("-")))

def save(name, string):
  file = open(name, "w")
  file.write("// autogenerated\n")
  file.write(string)
  file.close()

class Literal:
  def __init__(self, state, value, cvalue=None):
    self.value = value
    self.cvalue = cvalue or PREFIX+translate(value)

  def __str__(self):
    return self.value

  def cstr(self):
    return self.cvalue

def run_literal(state, parameters):
  for parameter in parameters:
    val__cval = parameter.split(",")
    lit = Literal(state, val__cval[0], 
                  cvalue = len(val__cval) > 1 and val__cval[1] or None)
    state["literals"] = state.get("literals", {})
    state["literals"][str(lit)] = lit

class LiteralType:
  def __init__(self, state, reference, literals):
    reference__default = reference.split("=")
    if len(reference__default) > 1:
      reference = reference__default[0]
      self.default = reference__default[1]
    else:
      self.default = None
    self.reference = reference
    self.literals = [state["literals"][l] for l in literals]

  def update(self, state, literals):
    self.literals += [state["literals"][l] for l in literals]

  def astr(self):
    names = self.reference.split(".")
    kind, object = ("", "")
    if len(names) > 1:
      kind, object = names
      kind = translate(kind)
    else:
      object = self.reference
    if kind:
      return PREFIX+kind+"__"+object+"Literals"
    return PREFIX+translate(object)+"Literals"

  def fstr(self):
    names = self.reference.split(".")
    kind, object = ("", "")
    if len(names) > 1:
      kind, object = names
      kind = translate(kind)
    else:
      object = self.reference
    object = translate(object)
    f = object
    if kind: f+="For"+kind
    return PREFIX+"Scan"+f

def run_ltype(state, parameters):
  reference = parameters[0]
  parameters = parameters[1:]
  state["ltypes"] = state.get("ltypes", {})
  if reference not in state["ltypes"]:
    ltype = LiteralType(state, reference, parameters)
    state["ltypes"][ltype.reference] = ltype
  else:
    state["ltypes"][reference].update(state, parameters)

def contract_for_reference(state, reference, name):
  if reference in state["ltypes"]:
    return ("self.{0} != SKUndefined && SKLiteralInGroup({0},{1})"
              .format(name,state["ltypes"][reference].astr()))
  if reference in state["ctypes"]:
    return state["ctypes"][reference].tstr()+"*"
  if reference == "string":
    return "self.{0} != nil".format(name)
  if reference == "number":
    return "self.{0} != nil".format(name)
  if reference == "double":
    return "1"
  if "[" in reference and "]" in reference:
    string = "self.{0} != nil && ".format(name)
    match = re.match("(.+)\\[(.*)\\]", reference)
    lengths = match.group(2)
    if len(lengths) == 0:
      string += "1"
    else:
      valid = []
      for l in lengths.split(","):
        valid += ["[self.{0} count] == {1}".format(name, l)]
      string += "(" + " || ".join(valid) + ")"
    return string

def format_character_for_reference(state, reference):
  if reference in state["ltypes"]:
    return "%@"
  if reference in state["ctypes"]:
    return "%@"
  if reference == "string":
    return "%@"
  if reference == "number":
    return "%@"
  if reference == "double":
    return "%f"
  if "[" in reference and "]" in reference:
    return "%@"

def call_for_format(state, reference, name):
  if reference in state["ltypes"]:
    return "SKLiteralString[self."+name+"]"
  if reference in state["ctypes"]:
    return "self."+name;
  if reference == "string":
    return "self."+name;
  if reference == "number":
    return "self."+name;
  if reference == "double":
    return "self."+name
  if "[" in reference and "]" in reference:
    return "[self."+name+" componentsJoinedByString:@\",\"]"

def type_for_reference(state, reference):
  if reference in state["ltypes"]:
    return "SKLiteral"
  if reference in state["ctypes"]:
    return state["ctypes"][reference].tstr()+"*"
  if reference == "string":
    return "NSString*"
  if reference == "number":
    return "NSNumber*"
  if reference == "double":
    return "double"
  if "[" in reference and "]" in reference:
    return "NSArray*"

def scanner_for_reference(state, reference):
  if reference in state["ltypes"]:
    return state["ltypes"][reference].fstr();
  if reference in state["ctypes"]:
    return state["ctypes"][reference].fstr()
  if reference == "string":
    return "SKScanString"
  if reference == "number":
    return "SKScanNumber"
  if reference == "double":
    return "SKScanDouble"
  if "[" in reference and "]" in reference:
    match = re.match("(.+)\\[\\]", reference)
    f = match.group(1).strip()
    return scanner_for_reference(state, f)+"Array"


def call_scanner(state, reference, name):
  if "[" in reference and "]" in reference:
    match = re.match("(.+)\\[(.*)\\]", reference)
    f = scanner_for_reference(state, match.group(1).strip())
    v = match.group(2)
    if len(v) == 0:
      v = "NULL"
    else:
      c = "\n      [NSArray arrayWithObjects:"
      for l in v.split(","):
        c+= "\n        [NSNumber numberWithInt:"+l+"],"
      c+= "nil]"
      v=c
    p = "(scanner,&"+name+",{f},{v})".format(f=f,v=v)
    return "SKScanArray"+p
  else:
    p = "(scanner,&"+name+")"
    return scanner_for_reference(state, reference) + p

class InstanceVariable:
  def __init__(self, state, reference, name):
    self.state = state
    self.reference = reference
    self.name = name

  def tstr(self):
    return type_for_reference(self.state, self.reference)

  def nstr(self):
    return self.name

  def dstr(self):
    if self.reference in self.state["ltypes"]:
      dref = self.state["ltypes"][self.reference].default
      if dref:
        return self.state["literals"][dref].cstr()
      return "SKUndefined"
    return None

  def ptr(self):
    return "*" in self.tstr()

class Branch:
  def __init__(self, state, parent, grammar):
    self.state = state
    self.ctype = parent
    self.grammar = grammar
    self.contract = {}
    self.content = ""
    self._format_str = ""
    self._format_args = []

    check = ""
    self.content = ""
    i = -1
    for point in self.grammar:
      i = i + 1
      var = re.match("^\\{(.+)\\}$", point)
      if var:
        name, type__op = var.group(1).split(":")
        reference = type__op
        if "==" in type__op:
          reference, lit = type__op.split("==")
          lit = self.state["literals"][lit].cstr()
          check = ("\n    if (b"+str(i)+" && "+name+str(i)+" != "+lit+") b"+
                   str(i)+"=NO;")
          self.contract[name] = "self.{0} == {1}".format(name,lit)
          self._format_str += format_character_for_reference(state, reference)
        else:
          check = ""
          self.contract[name] = contract_for_reference(self.state, 
                                                      reference, name)
          self._format_str += format_character_for_reference(state, reference)
        type = type_for_reference(self.state, reference)
        self._format_args += [call_for_format(state, reference, name)]
        self.content += """
    {type} {name}{0};
    BOOL b{0} = {scanner};{check}
    if (b{0}) result.{name} = {name}{0};
""".format(str(i), name=name, type=type, check=check,
     scanner = call_scanner(self.state,reference, name+str(i)))
      else:
        self._format_str += "%@"
        self._format_args += ["@\""+point+"\""]
        self.content += """
    BOOL b{0} = [scanner scanString:@"{point}" intoString:nil];
""".format(str(i), point=point)
    self.contract = " && ".join([self.contract[k] for k in self.contract])

  def bstr(self):
    return " && ".join(map(lambda i:"b"+str(i),range(0, len(self.grammar))))
  
  def format(self):
    return "@\""+self._format_str+"\""+","+",\n       ".join(self._format_args)
  
  def __str__(self):
    return self.content

  def is_state(self):
    return self.contract

class CompoundType:
  def __init__(self, state, reference, grammar):
    self.reference = reference
    self.variables = []
    self.branches = []

    self.update(state, grammar)

  def update(self, state, grammar):
    for point in grammar:
      var = re.match("^\\{(.+)\\}$", point)
      if var:
        name, type__op = var.group(1).split(":")
        type = type__op
        if "==" in type__op:
          type, lit = type__op.split("==")
        else:
          pass
        self.variables.append(InstanceVariable(state, type, name))
    self.branches.append(Branch(state, self, grammar))
  def ivars(self):
    d = {}
    for var in self.variables:
      d[var.name] = var
    return [d[k] for k in d]

  def tstr(self):
    return PREFIX + translate(self.reference)

  def fstr(self):
    return PREFIX + "Scan" + translate(self.reference)

def run_type(state, parameters):
  reference = parameters[0]
  parameters = parameters[1:]
  state["ctypes"] = state.get("ctypes", {})
  if reference not in state["ctypes"]:
    ctype = CompoundType(state, reference, parameters)
    state["ctypes"][ctype.reference] = ctype
  else:
    state["ctypes"][reference].update(state, parameters)

def run_attribute(state, parameters):
  attribute_name = parameters[0];
  type_reference = parameters[1];
  state["scanners"] = state.get("scanners", {})
  state["scanners"][attribute_name]=scanner_for_reference(state, type_reference)

  
main()





