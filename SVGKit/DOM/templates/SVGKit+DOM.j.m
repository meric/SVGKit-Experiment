// autogenerated

#import "SVGKit+DOM.h"
#import "SVGKit.h"

BOOL SKScanArray(NSScanner* scanner, NSArray** ptr, 
                 BOOL (*SKScanFN)(NSScanner*, id*), NSArray* valid) {
  NSUInteger location = scanner.scanLocation;
  NSMutableArray *array = [[[NSMutableArray alloc] init] autorelease];
  BOOL first = YES;
  while (true) {
    NSUInteger location = scanner.scanLocation;
    if (!first && !SKScanSeparator(scanner, nil)) {
        break;
    }
    first = NO;
    SKScanWhitespaces(scanner, nil);
    id object;
    if (SKScanFN(scanner, &object)) {
        [array addObject:(id)object];
        continue;
    }
    [scanner setScanLocation:location];
    break;
  }
  BOOL success = NO;
  if (valid && [valid count] > 0) {
    for (NSNumber *number in valid) {
      if ([array count] == [number intValue]) {
        success = YES;
        break;
      }
    }
  }
  else success = YES;
  if (success) {
    *ptr = array;
    return YES;
  }
  scanner.scanLocation = location;
  return NO;
}

// All literals in SVG specification.
NSString* SKLiteralString[SKUndefined] = { {% for lit in literals %}
  @"{{ lit }}",{% endfor %}
};

BOOL SKLiteralInGroup(SKLiteral literal, SKLiteral *valid) {
  while(*valid != SKUndefined) {
    if (literal == *valid++) {
      return YES;
    }
  }
  return NO;
}

BOOL SKScanLiteral(NSScanner* scanner, SKLiteral* ptr, SKLiteral* valid) {
  NSUInteger location = scanner.scanLocation;
  SKScanWhitespaces(scanner, nil);
  int i = 0;
  while(valid[i] != SKUndefined) {
    NSString *s = SKLiteralString[valid[i]];
    if ([scanner scanString:s intoString:nil]) {
      *ptr = valid[i];
      return YES;
    }
    i++;
  }
  scanner.scanLocation = location;
  return NO;
}
{% for ltype in ltypes %}
SKLiteral {{ltype.c_array_string()}}[] = {
  {% for literal in ltype.literals() %}{{literal.c_string()}},{% endfor %}SKUndefined
};

BOOL {{ltype.c_scan_function_string()}}(NSScanner* scanner, SKLiteral* ptr) {
  return SKScanLiteral(scanner, ptr, {{ltype.c_array_string()}});
}
{% endfor %}

{% for ctype in ctypes %}// {{ctype.c_type_string()}}
@implementation {{ctype.c_type_string()}}
{% for ivar in ctype.ivars() %}@synthesize {{ivar.name()}};
{% endfor %}
- (id)init {
  self = [super init];
  if (self) { {% for ivar in ctype.ivars() %}{% if ivar.c_default_string() %}
    {{ivar.name()}} = {{ivar.c_default_string()}};{% endif %}{% endfor %}
  }
  return self;
}

- (void)dealloc { {% for ivar in ctype.ivars() %}{% if ivar.is_ptr() %}
  self.{{ivar.name()}} = nil;{% endif %}{% endfor %}
  [super dealloc];
}

- (NSString*)description { {% for branch in ctype.branches() %}
  if ({{branch.c_is_state_string()}}) {
    return [NSString stringWithFormat:{{branch.c_format_string()}}];
  }
  {% endfor %}
  SKWarn(@"Cannot find suitable description %@", @"");
  return [super description];
}

@end

BOOL {{ctype.c_scan_function_string()}}(NSScanner* scanner, {{ctype.c_type_string()}}** ptr) {
  NSUInteger location = scanner.scanLocation;
  {% for branch in ctype.branches() %}{
    {{ctype.c_type_string()}}* result = [[{{ctype.c_type_string()}} new] autorelease];
    NSUInteger location = scanner.scanLocation;
    {{ branch }}
    if ({{branch.c_scan_success_string()}}) {
      *ptr = result;
      return YES;
    }
    scanner.scanLocation = location;
  }
  {% endfor %}scanner.scanLocation = location;
  return NO;
}

// Scan indeterminate sized array
BOOL {{ctype.c_scan_function_string()}}Array(NSScanner* scanner, NSArray** ptr) {
  return SKScanArray(scanner, ptr, {{ctype.c_scan_function_string()}}, NULL);
}

{% endfor %}

BOOL SKScanDoubleQuotedString(NSScanner *scanner, NSString **ptr)
{
    // CURRENTLY DOES NOT RESOLVE ESCAPED CHARACTERS
    
    NSUInteger location = scanner.scanLocation;
    SKScanWhitespaces(scanner, nil);
    NSString *string = [[scanner string] substringFromIndex:scanner.scanLocation];
    NSRegularExpression *pattern = 
    [NSRegularExpression regularExpressionWithPattern:@"^\".*[^\\\\]\"|^\"\"" //
                                              options:0 
                                                error:nil];
    
    
    NSArray* matches = [pattern matchesInString:string options:0 
                                          range:NSMakeRange(0,[string length])];
    if ([matches count] == 0) {
        scanner.scanLocation = location;
        return NO;
    }
    NSRange range = [[matches objectAtIndex:0] rangeAtIndex:0];
    NSString *value;
    assert([scanner scanString:[string substringWithRange:range]
                    intoString:&value]);
    *ptr = [value substringWithRange:NSMakeRange(1, [value length]-2)];
    return YES;
}

BOOL SKScanSingleQuotedString(NSScanner *scanner, NSString **ptr)
{
    // CURRENTLY DOES NOT RESOLVE ESCAPED CHARACTERS
    
    NSUInteger location = scanner.scanLocation;
    SKScanWhitespaces(scanner, nil);
    NSString *string = [[scanner string] substringFromIndex:scanner.scanLocation];
    NSRegularExpression *pattern = 
    [NSRegularExpression regularExpressionWithPattern:@"^'.*[^\\\\]'|^''"
                                              options:0 
                                                error:nil];
    
    
    NSArray* matches = [pattern matchesInString:string options:0 
                                          range:NSMakeRange(0,[string length])];
    if ([matches count] == 0) {
        scanner.scanLocation = location;
        return NO;
    }
    NSRange range = [[matches objectAtIndex:0] rangeAtIndex:0];
    NSString *value;
    assert([scanner scanString:[string substringWithRange:range]
                    intoString:&value]);
    *ptr = [value substringWithRange:NSMakeRange(1, [value length]-2)];
    return YES;
}

BOOL SKScanString(NSScanner *scanner, NSString **ptr)
{
    NSUInteger location = scanner.scanLocation;
    SKScanWhitespaces(scanner, nil);
    NSString *val;
    if (SKScanDoubleQuotedString(scanner, &val)) {
      *ptr = val;
      return YES;
    }
    if (SKScanSingleQuotedString(scanner, &val)) {
      *ptr = val;
      return YES;
    }
    NSCharacterSet *characterSet = 
    [[NSCharacterSet characterSetWithCharactersInString:@", 	"] invertedSet];
    NSString* value;
    if ([scanner scanCharactersFromSet:characterSet intoString:&value]) {
        *ptr = value;
        return YES;
    }
    location = scanner.scanLocation;
    return NO;
}

BOOL SKScanStringArray(NSScanner* scanner, NSArray** ptr) {
  return SKScanArray(scanner, ptr, SKScanString, NULL);
}

BOOL SKScanWhitespaces(NSScanner* scanner, NSString** ptr)
{
  return [scanner scanCharactersFromSet:
          [NSCharacterSet whitespaceCharacterSet] 
                             intoString:ptr];
}
BOOL SKScanSeparator(NSScanner *scanner, NSString** ptr)
{
  NSUInteger location = [scanner scanLocation];
  NSString *wsp = @"";
  BOOL w = SKScanWhitespaces(scanner, &wsp);
  NSString *cma = @"";
  BOOL c = [scanner scanString:@"," intoString:&cma];
  if (w || c) {
    if (ptr) {
        *ptr = [NSString stringWithFormat:@"%@%@", wsp, cma];
    }
    return YES;
  }
  [scanner setScanLocation:location];
  return NO;
}
BOOL SKScanNumber(NSScanner* scanner, NSNumber** num)
{
  double value;
  SKScanWhitespaces(scanner, nil);
  BOOL s = [scanner scanDouble:&value];
  if (s) {
    *num = [NSNumber numberWithDouble:value];
  }
  return s;
}

BOOL SKScanNumberArray(NSScanner* scanner, NSArray** ptr) {
  return SKScanArray(scanner, ptr, SKScanNumber, NULL);
}

BOOL SKScanDouble(NSScanner* scanner, double* value)
{
    SKScanWhitespaces(scanner, nil);
    return [scanner scanDouble:value];
}
